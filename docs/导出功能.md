# ChatGPT式对话应用导出功能设计

## 功能概述

本应用提供多样化的内容操作和导出功能，使用户能够：

1. 通过右键菜单复制对话内容
2. 将内容保存到应用内置剪贴板
3. 导出单条消息或整个对话为多种格式（Markdown、PDF、Word）
4. 支持自定义导出模板和样式

## 右键菜单设计

### 菜单功能和布局

```
┌─────────────────────────┐
│ 复制文本                │
│ 保存到剪贴板            │
├─────────────────────────┤
│ 导出为...               │ ─┐
│                         │  │  ┌───────────────┐
└─────────────────────────┘  └─►│ Markdown      │
                                │ PDF           │
                                │ Word文档      │
                                └───────────────┘
```

### 实现方式

```typescript
// 右键菜单组件
function ContextMenu({ position, messageId, conversationId, onClose }) {
  // 菜单位置状态
  const [pos, setPos] = useState({ x: position.x, y: position.y });
  
  // 处理复制文本
  const handleCopy = useCallback(async () => {
    const message = await getMessageById(messageId);
    await navigator.clipboard.writeText(message.content);
    toast({
      title: "复制成功",
      status: "success",
      duration: 2000,
    });
    onClose();
  }, [messageId, onClose]);
  
  // 处理保存到剪贴板
  const handleSaveToClipboard = useCallback(async () => {
    const message = await getMessageById(messageId);
    await saveToApplicationClipboard({
      content: message.content,
      source: {
        conversationId,
        messageId
      }
    });
    toast({
      title: "已保存到剪贴板",
      status: "success",
      duration: 2000,
    });
    onClose();
  }, [messageId, conversationId, onClose]);
  
  // 处理导出
  const handleExport = useCallback((format: 'markdown' | 'pdf' | 'word') => {
    exportMessage(messageId, format);
    onClose();
  }, [messageId, onClose]);
  
  // 菜单项配置
  const menuItems = [
    { label: '复制文本', onClick: handleCopy, icon: CopyIcon },
    { label: '保存到剪贴板', onClick: handleSaveToClipboard, icon: SaveIcon },
    { 
      label: '导出为...',
      isSubmenu: true,
      submenuItems: [
        { label: 'Markdown', onClick: () => handleExport('markdown'), icon: MarkdownIcon },
        { label: 'PDF', onClick: () => handleExport('pdf'), icon: PDFIcon },
        { label: 'Word文档', onClick: () => handleExport('word'), icon: WordIcon },
      ]
    }
  ];
  
  // 返回菜单UI
  return (
    <Portal>
      <Box
        position="fixed"
        top={pos.y}
        left={pos.x}
        zIndex={1000}
        bg="white"
        boxShadow="md"
        borderRadius="md"
        overflow="hidden"
        onMouseDown={(e) => e.stopPropagation()}
      >
        {/* 菜单项渲染... */}
      </Box>
    </Portal>
  );
}
```

### 激活方式

使用React的onContextMenu事件处理：

```typescript
function MessageItem({ message }) {
  const [contextMenu, setContextMenu] = useState(null);
  
  const handleContextMenu = useCallback((event) => {
    event.preventDefault();
    setContextMenu({
      position: { x: event.clientX, y: event.clientY },
      messageId: message.id,
      conversationId: message.conversationId
    });
  }, [message]);
  
  return (
    <>
      <Box
        onContextMenu={handleContextMenu}
        // 其他属性...
      >
        {message.content}
      </Box>
      
      {contextMenu && (
        <ContextMenu
          {...contextMenu}
          onClose={() => setContextMenu(null)}
        />
      )}
    </>
  );
}
```

## 剪贴板功能实现

### 数据模型

```typescript
interface ClipboardItem {
  id: string;        // 唯一标识
  content: string;   // 内容
  createdAt: number; // 创建时间戳
  source: {          // 来源信息
    conversationId: string;
    messageId: string;
  };
  tags?: string[];   // 可选标签
}
```

### 存储实现

使用IndexedDB存储剪贴板内容：

```typescript
import { openDB } from 'idb';

// 初始化数据库
async function initClipboardDB() {
  return openDB('ChatAppDB', 1, {
    upgrade(db) {
      if (!db.objectStoreNames.contains('clipboard')) {
        const store = db.createObjectStore('clipboard', { keyPath: 'id' });
        store.createIndex('createdAt', 'createdAt');
      }
    }
  });
}

// 保存到应用剪贴板
async function saveToApplicationClipboard(item: Omit<ClipboardItem, 'id' | 'createdAt'>) {
  const db = await initClipboardDB();
  const id = `clip-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  
  await db.add('clipboard', {
    id,
    ...item,
    createdAt: Date.now()
  });
  
  return id;
}

// 获取剪贴板内容
async function getClipboardItems(limit = 50): Promise<ClipboardItem[]> {
  const db = await initClipboardDB();
  return db.getAllFromIndex('clipboard', 'createdAt')
    .then(items => items
      .sort((a, b) => b.createdAt - a.createdAt)
      .slice(0, limit)
    );
}

// 删除剪贴板项
async function deleteClipboardItem(id: string): Promise<void> {
  const db = await initClipboardDB();
  return db.delete('clipboard', id);
}

// 清空剪贴板
async function clearClipboard(): Promise<void> {
  const db = await initClipboardDB();
  return db.clear('clipboard');
}
```

### 剪贴板UI组件

```typescript
function ClipboardPanel({ isOpen, onClose }) {
  const [items, setItems] = useState<ClipboardItem[]>([]);
  const [loading, setLoading] = useState(true);
  
  // 加载剪贴板内容
  useEffect(() => {
    if (isOpen) {
      setLoading(true);
      getClipboardItems()
        .then(fetchedItems => setItems(fetchedItems))
        .finally(() => setLoading(false));
    }
  }, [isOpen]);
  
  // 复制到系统剪贴板
  const handleCopy = useCallback(async (content: string) => {
    await navigator.clipboard.writeText(content);
    toast({ title: "已复制到剪贴板", status: "success" });
  }, []);
  
  // 删除项目
  const handleDelete = useCallback(async (id: string) => {
    await deleteClipboardItem(id);
    setItems(prev => prev.filter(item => item.id !== id));
    toast({ title: "已删除", status: "info" });
  }, []);
  
  // 导出项目
  const handleExport = useCallback((item: ClipboardItem, format: string) => {
    // 根据格式调用不同的导出函数
    switch (format) {
      case 'markdown':
        exportToMarkdown(item.content, `clip-${item.id}.md`);
        break;
      case 'pdf':
        exportToPDF(item.content, `clip-${item.id}.pdf`);
        break;
      case 'word':
        exportToWord(item.content, `clip-${item.id}.docx`);
        break;
    }
  }, []);
  
  return (
    <Modal isOpen={isOpen} onClose={onClose} size="xl">
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>应用剪贴板</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          {loading ? (
            <Center py={10}>
              <Spinner />
            </Center>
          ) : items.length === 0 ? (
            <Center py={10}>
              <Text color="gray.500">剪贴板为空</Text>
            </Center>
          ) : (
            <VStack spacing={3} align="stretch">
              {items.map(item => (
                <Box 
                  key={item.id} 
                  p={3} 
                  borderWidth="1px" 
                  borderRadius="md"
                  position="relative"
                >
                  <Text noOfLines={3}>{item.content}</Text>
                  <HStack spacing={2} mt={2}>
                    <IconButton
                      aria-label="复制"
                      icon={<CopyIcon />}
                      size="sm"
                      onClick={() => handleCopy(item.content)}
                    />
                    <Menu>
                      <MenuButton
                        as={IconButton}
                        aria-label="导出"
                        icon={<ExportIcon />}
                        size="sm"
                      />
                      <MenuList>
                        <MenuItem onClick={() => handleExport(item, 'markdown')}>
                          Markdown
                        </MenuItem>
                        <MenuItem onClick={() => handleExport(item, 'pdf')}>
                          PDF
                        </MenuItem>
                        <MenuItem onClick={() => handleExport(item, 'word')}>
                          Word文档
                        </MenuItem>
                      </MenuList>
                    </Menu>
                    <IconButton
                      aria-label="删除"
                      icon={<DeleteIcon />}
                      size="sm"
                      colorScheme="red"
                      variant="ghost"
                      onClick={() => handleDelete(item.id)}
                    />
                  </HStack>
                  <Text
                    position="absolute"
                    top={2}
                    right={2}
                    fontSize="xs"
                    color="gray.500"
                  >
                    {new Date(item.createdAt).toLocaleString()}
                  </Text>
                </Box>
              ))}
            </VStack>
          )}
        </ModalBody>
        <ModalFooter>
          <Button variant="ghost" onClick={onClose}>关闭</Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
}
```

## 格式导出功能

### Markdown导出实现

```typescript
// 导出消息为Markdown
async function exportToMarkdown(messageId: string, fileName?: string) {
  // 获取消息
  const message = await getMessageById(messageId);
  if (!message) return;
  
  // 创建markdown内容
  const markdown = `# ${message.role === 'user' ? '用户' : 'AI'} 消息 - ${new Date(message.timestamp).toLocaleString()}
  
${message.content}
  `;
  
  // 创建下载链接
  const blob = new Blob([markdown], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = fileName || `message-${messageId}.md`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// 导出整个对话为Markdown
async function exportConversationToMarkdown(conversationId: string) {
  // 获取对话信息
  const conversation = await getConversationById(conversationId);
  if (!conversation) return;
  
  // 获取所有消息
  const messages = await getMessagesByConversationId(conversationId);
  if (!messages || messages.length === 0) return;
  
  // 创建markdown内容
  let markdown = `# 对话：${conversation.title || '未命名对话'}
创建时间：${new Date(conversation.createdAt).toLocaleString()}
导出时间：${new Date().toLocaleString()}

`;
  
  // 添加所有消息
  for (const message of messages) {
    const role = message.role === 'user' ? '👤 用户' : 
                (message.role === 'assistant' ? '🤖 AI' : '🔧 系统');
    markdown += `## ${role} - ${new Date(message.timestamp).toLocaleString()}\n\n${message.content}\n\n---\n\n`;
  }
  
  // 创建下载链接
  const blob = new Blob([markdown], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `conversation-${conversationId}.md`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
```

### PDF导出实现

使用html2pdf.js库：

```typescript
import html2pdf from 'html2pdf.js';

// 导出消息为PDF
async function exportToPDF(messageId: string, fileName?: string) {
  // 获取消息
  const message = await getMessageById(messageId);
  if (!message) return;
  
  // 创建临时HTML元素
  const container = document.createElement('div');
  container.style.padding = '20px';
  container.style.maxWidth = '800px';
  container.style.margin = '0 auto';
  
  // 添加内容
  container.innerHTML = `
    <h1 style="color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 10px;">
      ${message.role === 'user' ? '用户' : 'AI'} 消息
    </h1>
    <p style="color: #7f8c8d; font-size: 14px;">
      ${new Date(message.timestamp).toLocaleString()}
    </p>
    <div style="margin-top: 20px; line-height: 1.6; white-space: pre-wrap;">
      ${formatMessageContent(message.content)}
    </div>
  `;
  
  // 配置PDF选项
  const options = {
    margin: [15, 15],
    filename: fileName || `message-${messageId}.pdf`,
    image: { type: 'jpeg', quality: 0.98 },
    html2canvas: { scale: 2, useCORS: true },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
  };
  
  // 生成PDF
  html2pdf().from(container).set(options).save();
}

// 格式化消息内容，将markdown渲染为HTML
function formatMessageContent(content: string) {
  // 这里可以使用marked库将markdown转为HTML
  // 或者使用其他格式化逻辑
  return content
    .replace(/\n/g, '<br>')
    .replace(/```(\w*)([\s\S]*?)```/g, (_, lang, code) => 
      `<pre style="background: #f5f5f5; padding: 10px; border-radius: 5px;"><code>${code}</code></pre>`
    );
}

// 导出整个对话为PDF
async function exportConversationToPDF(conversationId: string) {
  // 逻辑类似，但需要获取完整对话并格式化
  // ...
}
```

### Word文档导出实现

使用docx库：

```typescript
import { Document, Packer, Paragraph, TextRun, HeadingLevel } from 'docx';

// 导出消息为Word文档
async function exportToWord(messageId: string, fileName?: string) {
  // 获取消息
  const message = await getMessageById(messageId);
  if (!message) return;
  
  // 创建文档
  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        new Paragraph({
          text: `${message.role === 'user' ? '用户' : 'AI'} 消息`,
          heading: HeadingLevel.HEADING_1,
        }),
        new Paragraph({
          children: [
            new TextRun({
              text: new Date(message.timestamp).toLocaleString(),
              color: '7f8c8d',
              size: 24, // 12pt
            }),
          ],
        }),
        new Paragraph({}), // 空行
        ...convertContentToParagraphs(message.content)
      ],
    }],
  });
  
  // 生成blob
  const blob = await Packer.toBlob(doc);
  
  // 下载文件
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = fileName || `message-${messageId}.docx`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// 将消息内容转换为Word文档段落
function convertContentToParagraphs(content: string) {
  // 按行分割内容
  const lines = content.split('\n');
  
  // 转换为段落
  return lines.map(line => {
    // 这里可以添加更复杂的解析逻辑，如代码块、列表等
    return new Paragraph({
      text: line,
    });
  });
}

// 导出整个对话为Word
async function exportConversationToWord(conversationId: string) {
  // 逻辑类似，但需要获取完整对话并格式化
  // ...
}
```

## 导出样式和模板

### 自定义导出模板

```typescript
interface ExportTemplate {
  id: string;           // 模板唯一标识
  name: string;         // 模板名称
  format: 'markdown' | 'pdf' | 'word'; // 适用格式
  template: string;     // 模板内容或HTML模板
  createdAt: number;    // 创建时间
  lastUsed?: number;    // 最后使用时间
  isDefault?: boolean;  // 是否为默认模板
}

// 示例模板
const DEFAULT_TEMPLATES: ExportTemplate[] = [
  {
    id: 'default-markdown',
    name: '标准Markdown',
    format: 'markdown',
    template: `# {{{role}}} - {{{timestamp}}}

{{{content}}}

---`,
    createdAt: Date.now(),
    isDefault: true
  },
  {
    id: 'default-pdf',
    name: '标准PDF',
    format: 'pdf',
    template: `
<div style="font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px;">
  <h1 style="color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 10px;">
    {{{roleName}}}
  </h1>
  <p style="color: #7f8c8d; font-size: 14px;">
    {{{timestamp}}}
  </p>
  <div style="margin-top: 20px; line-height: 1.6; white-space: pre-wrap;">
    {{{formattedContent}}}
  </div>
</div>
    `,
    createdAt: Date.now(),
    isDefault: true
  }
];

// 使用模板导出
async function exportWithTemplate(messageId: string, templateId: string) {
  // 获取消息和模板
  const [message, template] = await Promise.all([
    getMessageById(messageId),
    getTemplateById(templateId)
  ]);
  
  if (!message || !template) return;
  
  // 准备替换数据
  const replaceData = {
    role: message.role,
    roleName: message.role === 'user' ? '用户消息' : 'AI回复',
    timestamp: new Date(message.timestamp).toLocaleString(),
    content: message.content,
    formattedContent: formatMessageContent(message.content)
  };
  
  // 应用模板（简单的模板替换）
  let result = template.template;
  for (const [key, value] of Object.entries(replaceData)) {
    const regex = new RegExp(`{{{${key}}}}`, 'g');
    result = result.replace(regex, value as string);
  }
  
  // 根据格式导出
  switch (template.format) {
    case 'markdown':
      // 导出Markdown
      const blob = new Blob([result], { type: 'text/markdown' });
      downloadBlob(blob, `message-${messageId}.md`);
      break;
    case 'pdf':
      // 使用HTML导出PDF
      const container = document.createElement('div');
      container.innerHTML = result;
      exportHTMLToPDF(container, `message-${messageId}.pdf`);
      break;
    case 'word':
      // 实现Word模板导出...
      break;
  }
  
  // 更新模板使用时间
  updateTemplateUsage(templateId);
}
```

### 导出偏好设置

```typescript
interface ExportSettings {
  defaultTemplates: {
    markdown: string; // 模板ID
    pdf: string;      // 模板ID
    word: string;     // 模板ID
  };
  includeTimestamp: boolean;
  includeSender: boolean;
  defaultFileName: string; // 支持变量如 {date}, {time}, {messageId}
  pdfOptions: {
    pageSize: 'a4' | 'letter' | 'legal';
    orientation: 'portrait' | 'landscape';
    margin: number; // mm
    headerTemplate?: string;
    footerTemplate?: string;
  };
  wordOptions: {
    format: 'docx' | 'rtf';
    includeTableOfContents: boolean;
  };
}

// 默认设置
const DEFAULT_EXPORT_SETTINGS: ExportSettings = {
  defaultTemplates: {
    markdown: 'default-markdown',
    pdf: 'default-pdf',
    word: 'default-word',
  },
  includeTimestamp: true,
  includeSender: true,
  defaultFileName: 'message-{messageId}-{date}',
  pdfOptions: {
    pageSize: 'a4',
    orientation: 'portrait',
    margin: 15
  },
  wordOptions: {
    format: 'docx',
    includeTableOfContents: false
  }
};

// 保存设置
function saveExportSettings(settings: ExportSettings) {
  localStorage.setItem('exportSettings', JSON.stringify(settings));
}

// 获取设置
function getExportSettings(): ExportSettings {
  const saved = localStorage.getItem('exportSettings');
  if (!saved) return DEFAULT_EXPORT_SETTINGS;
  
  try {
    return JSON.parse(saved) as ExportSettings;
  } catch (e) {
    console.error('解析导出设置失败', e);
    return DEFAULT_EXPORT_SETTINGS;
  }
}
```

## 浏览器兼容性考虑

对于不同浏览器的兼容性处理：

```typescript
// 检测浏览器功能
function checkBrowserCapabilities() {
  // 检查剪贴板API
  const hasClipboardAPI = navigator.clipboard && typeof navigator.clipboard.writeText === 'function';
  
  // 检查IndexedDB
  const hasIndexedDB = 'indexedDB' in window;
  
  // 检查Blob和URL API
  const hasBlobAndURL = 'Blob' in window && 'URL' in window && typeof URL.createObjectURL === 'function';
  
  return {
    clipboard: hasClipboardAPI,
    indexedDB: hasIndexedDB,
    blobAndURL: hasBlobAndURL
  };
}

// 根据浏览器能力提供备选方案
function copyTextFallback(text: string) {
  const capabilities = checkBrowserCapabilities();
  
  if (capabilities.clipboard) {
    // 使用现代剪贴板API
    return navigator.clipboard.writeText(text);
  } else {
    // 备选方案：使用document.execCommand (已废弃但兼容性好)
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    
    try {
      const success = document.execCommand('copy');
      if (!success) throw new Error('复制失败');
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    } finally {
      document.body.removeChild(textarea);
    }
  }
}
