# May应用前端存储最佳实践

## IndexedDB与LocalStorage使用边界

### LocalStorage适用场景
- **配置与设置**：用户偏好、主题设置等小体积配置数据
- **会话状态**：当前活动会话ID、UI状态等
- **临时缓存**：需要跨页面但不需要持久化的数据
- **加密后的敏感信息**：如API密钥（经过加密后）

```typescript
// 正确的LocalStorage使用示例
// 1. 存储简单配置
localStorage.setItem('theme', 'dark');

// 2. 存储加密的API密钥
const encryptedKey = encryptData(apiKey);
localStorage.setItem('api-key', encryptedKey);
```

### IndexedDB适用场景
- **大量结构化数据**：完整的对话历史、消息内容
- **需要索引和查询的数据**：按时间检索会话、按内容搜索消息
- **二进制数据**：图片、文件等媒体内容
- **需要事务支持的操作**：确保数据一致性的多步骤操作

```typescript
// 正确的IndexedDB使用示例
// 1. 保存完整对话
const conversation = {
  id: generateId(),
  title: '新对话',
  messages: [...],
  updatedAt: Date.now()
};

// 使用事务确保会话和元数据同时保存
const tx = db.transaction(['conversations', 'meta'], 'readwrite');
tx.objectStore('conversations').put(conversation);
tx.objectStore('meta').put({
  id: conversation.id,
  title: conversation.title,
  updatedAt: conversation.updatedAt
});
```

### 混合存储策略
在May应用中，我们采用混合存储策略，将两种存储机制结合使用：

1. **IndexedDB作为主存储**
   - 存储所有持久化数据（对话、消息、元数据）
   - 通过版本化管理支持数据模型演进
   - 利用索引支持高效检索

2. **LocalStorage作为辅助存储**
   - 存储用户配置和设置
   - 作为IndexedDB的缓存层，提升体验
   - 存储会话状态信息

3. **SessionStorage作为临时缓存**
   - 用于提升异步API的访问性能
   - 存储当前会话中多次使用的数据

## 数据加密策略

### 敏感数据处理
- **API密钥存储**：使用简单加密（base64）处理后存储
- **用户内容**：明文存储在用户本地，但可提供导出时加密选项
- **加密强度与用户体验平衡**：在纯前端应用中，需权衡安全性和便捷性

```typescript
// 简单的加密/解密实现
export const encryptData = (data: string): string => {
  return btoa(data); // 生产环境应使用更复杂的加密
};

export const decryptData = (encrypted: string): string => {
  try {
    return atob(encrypted);
  } catch (e) {
    return '';
  }
};
```

### 安全最佳实践
1. **不存储明文敏感信息**
2. **限制数据访问范围**
3. **提供清除数据功能**
4. **使用HTTPS部署**
5. **避免跨域存储共享**

## 存储版本管理和迁移

### IndexedDB版本控制
- **使用显式版本号**：通过递增数据库版本实现模式演进
- **在onupgradeneeded中处理迁移**：基于oldVersion逐步升级

```typescript
request.onupgradeneeded = (event) => {
  const db = (event.target as IDBOpenDBRequest).result;
  const oldVersion = event.oldVersion;
  
  // 版本1：创建基本对话存储
  if (oldVersion < 1) {
    // 创建初始对象存储
    db.createObjectStore('conversations', { keyPath: 'id' });
    db.createObjectStore('meta', { keyPath: 'id' });
  }
  
  // 版本2：添加配置存储
  if (oldVersion < 2) {
    // 添加新的对象存储
    db.createObjectStore('config', { keyPath: 'key' });
  }
  
  // 版本3：添加新字段或索引
  if (oldVersion < 3) {
    // 升级现有对象存储
    const store = tx.objectStore('conversations');
    store.createIndex('updatedAt', 'updatedAt', { unique: false });
  }
};
```

### 存储迁移策略
- **渐进式迁移**：每次版本更新只变更必要的部分
- **向后兼容**：新版本应能识别旧格式数据
- **数据完整性检查**：迁移后验证数据正确性

```typescript
// 数据迁移示例：从localStorage迁移到IndexedDB
export const migrateStorageToIndexedDB = async (): Promise<void> => {
  try {
    // 检查并迁移API密钥
    const legacyApiKey = localStorage.getItem('ark-api-key');
    if (legacyApiKey) {
      await saveConfig(CONFIG_KEYS.API_KEY, legacyApiKey);
    }
    
    // 迁移其他配置
    const legacyTheme = localStorage.getItem('app-theme');
    if (legacyTheme) {
      await saveConfig(CONFIG_KEYS.THEME, legacyTheme);
    }
    
    console.log('存储数据迁移完成');
  } catch (error) {
    console.error('迁移存储数据失败:', error);
  }
};
```

## 性能优化

### 减少存储操作
- **批量更新**：将多个更新合并为一个事务
- **节流保存**：对频繁变化的数据使用节流技术
- **懒加载策略**：按需加载数据，避免一次性加载全部内容

```typescript
// 使用防抖动保存机制
const debouncedSave = debounce((data) => {
  saveToIndexedDB(data);
}, 1000); // 1秒后执行实际保存

// 用户输入时调用
function handleInput(value) {
  setDraftMessage(value);
  debouncedSave(value);
}
```

### 索引优化
- **谨慎添加索引**：只为常用查询创建索引
- **复合索引**：对于多字段查询，使用复合索引
- **避免索引唯一字段**：除主键外，避免过多唯一索引

### 缓存策略
- **使用内存缓存**：频繁访问的数据保持在内存中
- **分级缓存**：结合SessionStorage作为IndexedDB的二级缓存
- **预加载关键数据**：提前加载可能需要的数据

```typescript
// 分级缓存示例
export const getApiKey = (): string => {
  try {
    // 首先检查SessionStorage缓存
    const cachedValue = sessionStorage.getItem('api-key-cache');
    if (cachedValue) {
      return cachedValue;
    }
    
    // 回退到异步获取，并在获取后缓存
    let result = '';
    getConfig(CONFIG_KEYS.API_KEY, '').then(value => {
      if (value) {
        result = decryptData(value);
        sessionStorage.setItem('api-key-cache', result);
      }
    });
    
    return result || '';
  } catch (e) {
    console.error('获取API密钥失败:', e);
    return '';
  }
};
```

## 错误处理与可靠性

### 错误捕获与恢复
- **包装存储操作**：使用try-catch包装所有存储操作
- **提供默认值**：在读取失败时返回安全的默认值
- **记录详细错误**：捕获并记录具体错误信息

```typescript
// 可靠的数据获取函数
async function getConversationSafely(id: string): Promise<Conversation | null> {
  try {
    const result = await getConversation(id);
    return result;
  } catch (error) {
    console.error(`获取对话${id}失败:`, error);
    // 通知用户
    showErrorNotification(`获取对话失败: ${error.message}`);
    return null;
  }
}
```

### 数据校验
- **输入验证**：存储前验证数据格式
- **完整性检查**：读取后验证数据完整性
- **数据修复**：尝试修复不完整的数据

```typescript
// 数据验证示例
function validateConversation(data: any): Conversation {
  // 确保必要字段存在
  if (!data.id) data.id = generateId();
  if (!data.title) data.title = '未命名对话';
  if (!data.messages) data.messages = [];
  if (!data.updatedAt) data.updatedAt = Date.now();
  
  return data as Conversation;
}
```

### 存储空间管理
- **监控存储使用**：检查可用存储空间
- **自动清理策略**：自动删除过期或不常用数据
- **压缩选项**：对大型数据提供压缩存储

```typescript
// 存储空间检查
async function checkStorageQuota() {
  if (navigator.storage && navigator.storage.estimate) {
    const estimate = await navigator.storage.estimate();
    const percentUsed = (estimate.usage / estimate.quota) * 100;
    
    if (percentUsed > 80) {
      // 警告用户存储空间不足
      showWarning('存储空间即将用尽，请考虑清理旧数据');
    }
  }
}
```

## 总结

在May应用中，我们采用了以下前端存储最佳实践：

1. **明确的存储边界**：IndexedDB用于结构化数据，LocalStorage用于配置和缓存
2. **版本化的数据模型**：支持渐进式数据结构升级
3. **分层缓存策略**：结合内存、SessionStorage和IndexedDB的多层缓存
4. **优雅的错误处理**：确保存储操作的可靠性和用户体验
5. **数据安全考虑**：对敏感信息进行适当保护
6. **性能优化**：通过批处理、缓存和索引优化提升性能

这些最佳实践确保了May应用在无后端架构下依然能够提供流畅、可靠的用户体验。
